"""Autogenerated solution template, v2"""
__version__ = 2

from collections import deque
from typing import Generator, List, Any, Tuple
from framework.input_helper import read_entire_input
from lib.asciimap import DenseAsciiMap, SparseAsciiMap
from lib.graph.pathfinding import search

YEAR = 2024
DAY = 10
VERSION = "None"

data = read_entire_input(2024,10)
test = """89010123
78121874
87430965
96549874
45678903
32019012
01329801
10456732""".split("\n")

Position = tuple[int,int]

def parse(data: List[str]) -> SparseAsciiMap:
    ascmap: SparseAsciiMap = SparseAsciiMap(data, ignore = "", store_reverse_lookup=True, mut = int)
    return ascmap

def find_all_trailheads(ascmap: SparseAsciiMap) -> Generator[tuple[int,int],Any,Any]:
    yield from ascmap.reverse_lookup[0]

def neighbour(ascmap: SparseAsciiMap):
    DIR = [(1,0),(0,1),(-1,0),(0,-1)]
    def f(position):
        current_height = ascmap.mapdata[position]
        for dx,dy in DIR:
            nx, ny = position[0]+dx, position[1]+dy
            if (nx,ny) in ascmap and ascmap.mapdata[(nx,ny)] == current_height + 1:
                yield (nx,ny), 1
    return f

def calculate_score(ascmap: SparseAsciiMap) -> int:
    score = 0
    for trailhead in find_all_trailheads(ascmap):
        visited_from, _ = search(trailhead, neighbour(ascmap))
        for pos, d in visited_from.items():
            if d['depth'] == 9:
                score += 1
    return score

def part_one(data: List[str], verbose=False):
    ascmap = parse(data)
    return calculate_score(ascmap)

def find_all_summits(ascmap: SparseAsciiMap) -> Generator[Position,Any,Any]:
    yield from ascmap.reverse_lookup[9]


def find_paths(ascmap: SparseAsciiMap, trailhead: Position) -> int:
    paths = deque()
    paths.append([trailhead])
    complete_paths = []
    while len(paths) > 0:
        path = paths.pop()
        if len(path) == 10:
            complete_paths.append(path)
            continue
        neighbours = [n for n, _ in neighbour(ascmap)(path[-1])]
        for n in neighbours:
            new_path = path + [n]
            paths.append(new_path)
    
    return complete_paths

def part_two(data: List[str], verbose=False):
    ascmap = parse(data)
    result = 0
    for trailhead in find_all_trailheads(ascmap):
        trail_graph = find_paths(ascmap, trailhead)
        result += len(trail_graph)
    return result

if __name__ == "__main__":
    data = read_entire_input(YEAR, DAY)
    part_one(data)
    part_two(data)