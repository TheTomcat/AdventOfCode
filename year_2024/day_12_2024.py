"""Autogenerated solution template, v2"""
__version__ = 2

from collections import defaultdict
from typing import List, Any, Tuple
from framework.input_helper import read_entire_input
from lib.asciimap import DenseAsciiMap, Position, UDLR, UP, DOWN, LEFT, RIGHT
from lib.graph.pathfinding import search
from rich import print

from lib.iterators import window

YEAR = 2024
DAY = 12
VERSION = "None"

data = read_entire_input(2024,12)
test = """RRRRIICCFF
RRRRIICCCF
VVRRRCCFFF
VVRCCCJFFF
VVVVCJJCFE
VVIVCCJJEE
VVIIICJJEE
MIIIIIJJEE
MIIISIJEEE
MMMISSJEEE""".split("\n")

def parse(data: List[str]) -> DenseAsciiMap:
    ascmap = DenseAsciiMap(data,store_reverse_lookup=True)
    return ascmap

def neighbours(ascmap: DenseAsciiMap):
    def f(position: tuple[int,int]):
        x,y = position
        if (x,y) not in ascmap:
            raise IndexError
        v = ascmap[x,y]
        for dx, dy in UDLR:
            nx, ny = x+dx, y+dy
            if (nx,ny) in ascmap and ascmap[nx,ny] == v:
                yield (nx, ny), 1
    return f

def find_regions(ascmap: DenseAsciiMap):
    accounted = set()
    regions = defaultdict(list)
    keys = list(ascmap.reverse_lookup.keys())
    key = -1
    while len(keys) > 0:
        key = keys[-1]
        for point in ascmap.reverse_lookup[key]:
            if point in accounted:
                continue
            region = flood_fill(ascmap, point)
            regions[key].append(region)
            for point in region:
                if point in accounted:
                    raise ValueError("This should not be!")
                accounted.add(point)
        accounted_size = sum(len(a) for a in regions[key])
        expected_size = len(ascmap.reverse_lookup[key])
        if accounted_size == expected_size:
            keys.pop()
    return regions


def flood_fill(ascmap: DenseAsciiMap, start: Position):
    vf, _ = search(start, neighbours(ascmap))
    return set(vf.keys())

def color(v, p = None):
    "Highlight all cells that are 'v' red, and all positions in P green"
    def f(x,y,z):
        if p is not None and (x,y) in p:
            return f'[green]{z}[/green]'
        if v == z:
            return f'[red]{z}[/red]'
        return z
    return f

def area(region: set[Position]) -> int:
    return len(region)

def has_boundary(ascmap: DenseAsciiMap, region, p1: Position, p2: Position, regionstr: str, verbose=False):
    if verbose:
        print(f"Examining {p1}->{p2}", end="")
    if p1 not in region and p2 in region and ascmap[p2] == regionstr:
        if verbose:
            print(f"{p1} not in map. Perimeter start")
        return True
    if p2 not in region and p1 in region and ascmap[p1] == regionstr:
        if verbose:
            print(f"{p2} not in map. Perimeter start")
        return True
    a = '*' if p1 not in region else ascmap[p1]
    b = '*' if p2 not in region else ascmap[p2]
    in_region = a == regionstr or b == regionstr
    on_boundary = in_region and a != b
    if verbose:
        print(f"(x,y) = {ascmap[p1]}, (nx,y) = {ascmap[p2]}")
        print(ascmap.render(format=color(regionstr, [p1, p2])))
        print(on_boundary)
        input()
    return on_boundary 

def get_bounding_box(region: set[Position]):
    X = [a for a,b in region]
    Y = [b for a,b in region]
    xmin, xmax = min(X), max(X)
    ymin, ymax = min(Y), max(Y)
    return xmin, xmax, ymin, ymax

def perimeter(ascmap: DenseAsciiMap, region: set[Position], regioncode: str, verbose = False) -> int:
    v = regioncode
    xmin, xmax, ymin, ymax = get_bounding_box(region)
    if verbose:
        print(f'{xmin=}, {xmax=}, {ymin=}, {ymax=}')
    if xmax - xmin == 0 or ymax - ymin == 0:
        return 2 * (xmax - xmin +1 + ymax - ymin+1)
    count = 0
    for y in range(ymin, ymax+1):
        for x, nx in window(range(xmin-1, xmax+2)):
            count += has_boundary(ascmap, region, (x,y), (nx,y), v, verbose)
            
    for x in range(xmin, xmax+1):
        for y, ny in window(range(ymin-1, ymax+2)):
            count += has_boundary(ascmap, region, (x,y), (x,ny), v, verbose)
    return count


def part_one(data: List[str], verbose=False):
    ascmap = parse(data)
    regions = find_regions(ascmap)
    tot = 0
    for v, regionlist in regions.items():
        for region in regionlist:
            a = area(region)
            p = perimeter(ascmap, region, v)
            if verbose:
                print(f"A region of {v} with price {a} * {p} = {a*p}")
            tot += a*p
    return tot

def ordered(p1, p2):
    return tuple(sorted([p1,p2]))

def count_individual_sides(ascmap: DenseAsciiMap, region: set[Position], regioncode: str, verbose: bool = False):
    xmin, xmax, ymin, ymax = get_bounding_box(region)
    start = sorted(list(region), key=lambda x: x[0])[0]
    
    sides = set()
    v = regioncode
    xmin, xmax, ymin, ymax = get_bounding_box(region)
    if verbose:
        print(f'{xmin=}, {xmax=}, {ymin=}, {ymax=}')
    for y in range(ymin, ymax+1):
        for x, nx in window(range(xmin-1, xmax+2)):
            if has_boundary(ascmap, region, (x,y), (nx,y), v, verbose):
                sides.add(ordered((x,y),(nx,y)))
            
    for x in range(xmin, xmax+1):
        for y, ny in window(range(ymin-1, ymax+2)):
            if has_boundary(ascmap, region, (x,y), (x,ny), v, verbose):
                sides.add(ordered((x,y),(x,ny)))
    
    p = start
    # Walk around the exterior until we reach the start again
    traced = set()
    corners = 0

    while traced != sides:
        edge = [(p1,p2) for p1,p2 in sides if p1 == start or p2 == start]
        

    return sides


def part_two(data: List[str], verbose=False):
    _ = parse(data)

    return False

if __name__ == "__main__":
    data = read_entire_input(YEAR, DAY)
    part_one(data)
    part_two(data)