"""Autogenerated solution template, v2"""
__version__ = 2

from typing import List, Any, Tuple

from tqdm import tqdm
from framework.helpers import solution_timer
from framework.input_helper import read_entire_input

data = read_entire_input(2024,6)
test = """....#.....
.........#
..........
..#.......
.......#..
..........
.#..^.....
........#.
#.........
......#...""".split("\n")

DIR = {
    '^': (0,-1),
    '>': (1,0),
    'v': (0,1),
    '<': (-1,0)
}

Position = tuple[int,int]
AsciiMap = dict[Position,str]

def parse(data: List[str]) -> tuple[AsciiMap, int, int, Position, Position]:
    mapdata: AsciiMap = {}
    for y, row in enumerate(data):
        for x, col in enumerate(row):
            mapdata[(x,y)] = col
            if col in DIR:
                guardpos = (x,y)
                direction = DIR[mapdata[(x,y)]]
                mapdata[(x,y)] = "."
    H = len(data)
    W = len(data[0])
    # direction = DIR[mapdata[guardpos]]
    return mapdata, W, H, guardpos, direction

def render(mapdata: AsciiMap, W: int, H: int, path: List[Position], guard: Position, direction: Position):
    rDIR = {v:k for k,v in DIR.items()}
    
    for y in range(H):
        for x in range(W):
            if (x,y) == guard:
                p = rDIR[direction]
            elif (x,y) in path:
                p = "X"
            else:
                p = mapdata[(x,y)]
            print(p, end="")
        print()

def step(mapdata: AsciiMap, guard: tuple[int,int], direction: str) -> tuple[Position,Position]:
    #can I step
    x,y = guard
    # dx,dy = DIR[mapdata[guard]]
    dx,dy = direction
    nx, ny = x+dx, y+dy
    if (nx,ny) not in mapdata or mapdata[(nx,ny)] == '.' or mapdata[(nx,ny)] in DIR:
        return (nx,ny),(dx,dy)
    if mapdata[(nx,ny)] == '#':
        return (x,y),(-dy,dx)
    

#@solution_timer(2024,6,1)
def part_one(data: List[str], verbose=False):
    mapdata, W, H, guard, direction = parse(data)
    path = []
    while 0<=guard[0]<W and 0<=guard[1]<H:
        path.append(guard)
        # input(f"{guard}, {direction}")
        if verbose:
            render(mapdata, W, H, path, guard, direction)
            print(len(set(path)), path)
            input()
        guard, direction = step(mapdata, guard, direction)
        # guard, direction = new_guard, new_direction
    # print(set(path))
    return len(set(path))

def find_loop(mapdata: AsciiMap, W: int, H: int, guard: Position, direction: Position, verbose: bool = False) -> bool:
    path = []
    state_track = set()
    steps = 0
    while 0<=guard[0]<W and 0<=guard[1]<H:
        if steps >= 1E6:
            raise OverflowError("Too many steps!")
        steps += 1
        path.append(guard)
        
        if (guard,direction) in state_track:
            if verbose:
                print("LOOP")
            return True

        state_track.add((guard,direction))
        
        # input(f"{guard}, {direction}")
        if verbose:
            render(mapdata, W, H, path, guard, direction)
            print(len(set(path)), path)
            input()
        guard, direction = step(mapdata, guard, direction)
        # guard, direction = new_guard, new_direction
    # print(set(path))
    return False

#@solution_timer(2024,6,2)
def part_two(data: List[str], verbose=False):
    mapdata, W, H, guard0, direction0 = parse(data)
    
    breakout = False
    tot = 0
    if verbose:
        it = tqdm(range(H))
    else:
        it = range(H)
    for y in it:
        # print(y)
        for x in range(W):
            guard, direction = guard0, direction0
            if mapdata[(x,y)] == '#':
                # breakout = True
                continue
            mapdata[(x,y)] = "#"
            if find_loop(mapdata, W, H, guard, direction):
                if verbose:
                    print(x,y)
                tot += 1
            mapdata[(x,y)] = "."
    return tot

    


if __name__ == "__main__":
    data = read_entire_input(2024,6)
    part_one(data)
    part_two(data)