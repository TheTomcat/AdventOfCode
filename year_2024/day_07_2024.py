"""Autogenerated solution template, v2"""
__version__ = 2

from collections import deque
from itertools import zip_longest
from typing import List, Any, Tuple
from framework.helpers import solution_timer
from framework.input_helper import read_entire_input

from lib.graph.pathfinding import search

data = read_entire_input(2024,7)
test = """190: 10 19
3267: 81 40 27
83: 17 5
156: 15 6
7290: 6 8 6 15
161011: 16 10 13
192: 17 8 14
21037: 9 7 18 13
292: 11 6 16 20""".split("\n")

Operands = List[int]

def parse(data: List[str]) -> List[tuple[int, Operands]]:
    operations:List[tuple[int, List[int]]] = []
    for row in data:
        a,b = row.split(": ")
        operands = list(map(int, b.split(" ")))
        operations.append((int(a), operands))
    return operations

def make_operations(total: int, operands: Operands):
    L = len(operands) - 1
    is_multiply_reversed = [] # A list of operations applied backwards
    for i, operand in enumerate(reversed(operands)):
        subtotal = apply_backwards(total, operands, is_multiply_reversed)
        if subtotal == int(subtotal):
            if subtotal % operand == 0:
                is_multiply_reversed.append(True)
            else:
                is_multiply_reversed.append(False)
            # try multiplication
        else:
            is_multiply_reversed[-1] = False  
    is_multiply = list(reversed(is_multiply_reversed))
    return is_multiply

def apply_backwards(total: int, operands: Operands, operators_reversed: list[bool]):
    for i, (operator, operand) in enumerate(zip(operators_reversed, reversed(operands))):
        # operand = operands[-i-1]
        if operator == 1:
            total /= operand
        elif operator == 0:
            total -= operand
        elif operator == 2:
            # if f'{total}'.endswith(f'{operand}'):
                # print(">>", total, total // 10**(len(f'{operand}')))
            total = total // 10**(len(f'{operand}'))
    return total

OPS = {
    0:"+",
    1:"*",
    2:"||"
}

def display_operation(total: int, operands: Operands, operations_reversed: List[bool]):
    # output = [f'{a}{b}' for a,b in zip(operands,['*' if op else '+' for op in is_multiply[::-1]])]
    output = [f'{a}{b}' for a,b in zip(operands,[OPS[op] for op in operations_reversed[::-1]])]
    equation = f"{''.join(output)}{operands[-1]}"
    actual = apply_operations(operations_reversed, operands)
    return f"{total} =?= {equation} = {actual}"

def build_operations(total: int, operands: Operands, verbose=False):
    op_frontier = deque()
    # a deque of List[bool] in reverse, of max length operands-1
    target = operands[0]
    p_operands = operands[:0:-1]
    # operations = []
    op_frontier.append([False])
    # if total % target == 0: 
    op_frontier.append([True])

    while len(op_frontier) > 0:
        is_multiply = op_frontier.pop()
        if verbose:
                    # if verbose:
            output = [f'{a}{b}' for a,b in zip(operands,['*' if op else '+' for op in is_multiply[::-1]])]
            equation = f"{''.join(output)}{operands[-1]}"
            actual = apply_operations(is_multiply, operands)
            print(f"{total} =?= {equation} = {actual}", end="")
            # print(f"Examining {is_multiply}")
        # Test the operations
        subtot = total
        for is_mul, b in zip(is_multiply, p_operands):
            if is_mul:
                subtot /= b
            else:
                subtot -= b
        if subtot == target and len(is_multiply) == len(operands)-1:
            if verbose:
                print(f"\n>>> Found solution! {total} = {equation}")
            return is_multiply
        if verbose:
            print(f" >> discarding (residual {subtot} from {operands})")
        if subtot == int(subtot) and len(is_multiply) < len(p_operands):
            # if subtot % p_operands[len(is_multiply)] == 0:

            op_frontier.append(is_multiply + [0])
            op_frontier.append(is_multiply + [1])
            
            # op_frontier.append(is_multiply + [2])
    if verbose:
        input("No solution found...")
    return None

def apply_operations(reversed_operations: List[bool], operands: Operands) -> int:
    tot = operands[0]
    forward_operations = reversed_operations[::-1]
    p_operands = operands[1:]
    for is_mul, b in zip(forward_operations, p_operands):
        if is_mul == 0:
            tot += b
        elif is_mul == 1:
            tot *= b
        elif is_mul == 2:
            tot = int(f"{tot}{b}")
    return tot

# @solution_timer(2024,7,1)
# def part_one(data: List[str], verbose=False):
#     operations = parse(data)
#     count = 0
#     calibration_result = 0
#     for total, operands in operations:
#         ops = build_operations(total, operands, verbose)
#         if ops is None: 
#             continue
#         else:
#             # print(list(reversed(ops)))
#             calibration_result += apply_operations(ops, operands)
        
#         if verbose:
#             input()
#         # ops = make_operations(total, operands)
#         # if verbose:
#         #     output = [f'{a}{b}' for a,b in zip(operands,['*' if op else '+' for op in ops[:-1]])]
#         #     print(f"{total} = {''.join(output)}{operands[-1]}")
#         # print(apply_backwards(total, operands, ops))
#         #     # print()
#         #     # count += 1
#     return calibration_result

def int_endswith(bigint: int, ending: int) -> bool:
    return f'{int(bigint)}'.endswith(f'{int(ending)}')

def int_strip(bigint: int, ending_to_strip: int) -> bool:
    return bigint // 10**(len(f'{ending_to_strip}')) if int_endswith(bigint, ending_to_strip) else 0.5

def get_neighbours(total: int, operands: Operands, include_concat=False):
    def f(reversed_operations: Tuple[bool]) -> List[Tuple[bool]]:
        if len(reversed_operations) < len(operands):
            subtot = apply_backwards(total, operands, reversed_operations)
            next_operand = operands[-len(reversed_operations)-1]
            # print(f'{total=} {reversed_operations=} {subtot=} {next_operand=} {operands=}')
            output = []
            if subtot % next_operand == 0:
                output.append((reversed_operations+(1,), 1))
            if include_concat and int_endswith(subtot, next_operand):
                output.append((reversed_operations+(2,), 1))
            output.append((reversed_operations+(0,), 1))

            return output #[(reversed_operations+(0,), 1), (reversed_operations+(2,), 1)]
        return []
    return f
    

def halt_at(total: int, operands: Operands) -> bool:
    def f(reversed_operations: List[bool]):
        return apply_operations(reversed_operations, operands) == total and \
                len(reversed_operations) + 1 == len(operands)
    return f

#@solution_timer(2024,7,1)
def part_one(data: List[str], verbose=False):
    operations = parse(data)
    calibration_result = 0
    for total, operands in operations:
        visited_from, end = search(tuple(), get_neighbours(total, operands), halt_at(total, operands))
        if end is not None:
            if verbose:
                print(display_operation(total, operands, end))
            calibration_result += apply_operations(end, operands)
        else:
            if verbose:
                print("X " + f"{total} != {" ".join(f'{o}' for o in operands)}")
        # if verbose:
        #     input()
    return calibration_result

#@solution_timer(2024,7,2)
def part_two(data: List[str], verbose=False):
    operations = parse(data)
    calibration_result = 0
    for total, operands in operations:
        visited_from, end = search(tuple(), get_neighbours(total, operands, True), halt_at(total, operands))
        if end is not None:
            if verbose:
                print(display_operation(total, operands, end))
            calibration_result += apply_operations(end, operands)
        else:
            if verbose:
                print("X " + f"{total} != {" ".join(f'{o}' for o in operands)}")
        # if verbose:
        #     input()
    return calibration_result

if __name__ == "__main__":
    data = read_entire_input(2024,7)
    part_one(data)
    part_two(data)