"""Autogenerated solution template, v2"""
__version__ = 2

from typing import List, Any, Tuple
from framework.helpers import solution_timer
from framework.input_helper import read_entire_input

from lib.iterators import grouper, window

data = read_entire_input(2024,9)
test = """2333133121414131402""".split("\n")

Filesystem = List[Tuple[int,int,int]]

def parse(data: List[str]) -> Filesystem:
    filesystem = []
    for id, (filesize, blanksize) in enumerate(grouper(2, data[0], 0)):
        filesystem.append((id, int(filesize), int(blanksize)))
    return filesystem

def iterate_in_reverse_without_blanks(filesystem: Filesystem):
    "Yield a bitstring of ids starting from the end of the file working backwards"
    for id, filesize, blanksize in reversed(filesystem):
        for _ in range(filesize):
            yield id

def write_filesystem_fragmented(filesystem: Filesystem) -> List[int]:
    "Write the filesystem to disk using the part one implementation"
    used_space = sum(a for _,a,_ in filesystem)

    disk = [None] * used_space

    write_pos = 0
    reverse_reader = iterate_in_reverse_without_blanks(filesystem)

    for id, filesize, blanksize in filesystem:
        for _ in range(filesize):
            disk[write_pos] = id
            write_pos += 1
            if write_pos == used_space:
                return disk
            
        for _ in range(blanksize):
            disk[write_pos] = next(reverse_reader)
            write_pos += 1
            if write_pos == used_space:
                return disk
        # print(''.join(f'{a}' for a in disk))

def compute_checksum(disk: List[int]):
    return sum(pos*id if isinstance(id, int) else 0 for pos, id in enumerate(disk))

#@solution_timer(2024,9,1)
def part_one(data: List[str], verbose=False):
    filesystem = parse(data)
    disk = write_filesystem_fragmented(filesystem)
    return compute_checksum(disk)

def normalise(filesystem: Filesystem):
    "Get a list of the blank spaces, of the form [start_index, blank_length]"
    blank_spaces = [] # start, length
    pointer = 0
    for id, file, blank in filesystem:
        pointer += file
        if file == 0:
            blank_spaces[-1][1] += blank
            blank
        else:
            if blank > 0:
                blank_spaces.append([pointer, blank])
        pointer += blank
    return blank_spaces

def naive_filesystem(filesystem: Filesystem):
    "The filesystem as a list of ids. '.' represents an empty space"
    filesystem_size = sum(a+b for _,a,b in filesystem)
    disk = ['.'] * filesystem_size
    pointer = 0
    for id, filesize, blanksize in filesystem:
        disk[pointer:pointer+filesize] = [id] * filesize
        pointer += filesize + blanksize
    return disk



def write_filesystem_unfragmented(filesystem: Filesystem, verbose: bool = False) -> List[int]:
    blank_spaces = normalise(filesystem)
    # input(blank_spaces)
    filesystem_size = sum(a+b for _,a,b in filesystem)
    #disk = ['.'] * filesystem_size
    disk = naive_filesystem(filesystem)
    end_pointer = filesystem_size
    forward_pointer = 0
    
    for id, filesize, blanksize in reversed(filesystem): 
        # Starting from the last file in the group, find the first blank space that fits the file
        end_pointer -= (filesize + blanksize) # This is effectively the new EOF
        for index, (start, blank_length) in enumerate(blank_spaces):
            
            if filesize <= blank_length and start < end_pointer: # We've found the first space that is suitable
                if verbose: 
                    print(f"Found a blank at {start} of length {blank_length} to fit file {id=}")
                    print(f"   Overwriting {disk[start:start+filesize]} with {[id]*filesize}")
                #assert disk[start:start+filesize] == ['.'] * filesize
                disk[start:start+filesize] = [id] * filesize # Store the file 'id' on the disk
                if verbose:
                    print(f"   Removing {id=} {filesize=} from position {end_pointer=}")
                    print(f"   {disk[end_pointer:end_pointer+filesize]}")
                # assert disk[end_pointer:end_pointer+filesize] == [id] * filesize
                disk[end_pointer:end_pointer+filesize] = ['.'] * filesize # Remove 'id' from its original position


                # update the blank index for the overwritten blanks
                if blank_length - filesize == 0: # If we've perfectly filled the void, remove this blank space
                    blank_spaces.pop(index)
                else: # Otherwise, update the pointer to account for [newfile......]
                    blank_spaces[index] = [start + filesize, blank_length-filesize]
                break
    return disk



#@solution_timer(2024,9,2)
def part_two(data: List[str], verbose=False):
    filesystem = parse(data)    
    disk = write_filesystem_unfragmented(filesystem, verbose)
    return compute_checksum(disk)

if __name__ == "__main__":
    data = read_entire_input(2024,9)
    part_one(data)
    part_two(data)