"""Autogenerated solution template, v2"""
__version__ = 2

from typing import List, Any, Tuple
from framework.helpers import solution_timer
from framework.input_helper import read_entire_input
from rich import print
from lib.shared import PointDict

data = read_entire_input(2023,3)
test = """467..114..
...*......
..35..633.
......#...
617*......
.....+.58.
..592.....
......755.
...$.*....
.664.598..""".split("\n")

test1 = """12.......*..
+.........34
.......-12..
..78........
..*....60...
78..........
.......23...
....90*12...
............
2.2......12.
.*.........*
1.1.......56""".split("\n")

test2 = """12.......*..
+.........34
.......-12..
..78........
..*....60...
78.........9
.5.....23..$
8...90*12...
............
2.2......12.
.*.........*
1.1..503+.56""".split('\n')

def parse(data: List[str]):
    digits: dict[Tuple[int, int], str] = {}
    prev = ''
    starts: List[Tuple[int,int,int]] = []
    stars: List[Tuple[int,int]] = []
    for y, row in enumerate(data):
        prev = '.'
        for x, d in enumerate(row):
            if not prev.isdigit() and d.isdigit():
                start = (x,y)
            if prev.isdigit() and not d.isdigit():
                starts.append((*start, x-start[0]))
            elif d.isdigit() and x == len(row)-1:
                starts.append((*start, x-start[0]+1))
            if d == '*':
                stars.append((x,y))
                # print(f'.{starts[-1]}')
            # if not prev.isdigit() and d.isdigit():
            #     start = (x,y)
            # if (prev.isdigit() and not d.isdigit() ):
            #     starts.append((*start, x-start[0]))
            # elif (prev.isdigit() and x == len(row)-1 ):
            #     starts.append((*start, x-start[0]+1))
            digits[(x,y)] = d
            prev = d
    return digits, starts, stars

def const(i):
    while True:
        yield i

def iterate_around(start: Tuple[int, int], length):
    yield start[0]-1, start[1]
    yield from zip(range(start[0]-1,start[0]+length+1), const(start[1]+1))
    yield start[0]+length, start[1]
    # yield start[0]+length+1, start[1]-1
    yield from zip(range(start[0]+length, start[0]-2, -1), const(start[1]-1))

def get_digit(digits, x0, y0, l):
    return ''.join([digits[c] for c in [(x,y0) for x in range(x0,x0+l)]])

def pprint(x0, y0, x, y, l, digits, H, W, is_found, surrounds):
    for yi in range(y0-3, y0+3):
        for xi in range(x0-3, x0+l+3):
            if yi == y0 and x0 <= xi < x0+l and is_found:
                st = '[red]'
                en = '[/red]'
            elif yi == y0 and x0 <= xi < x0+l:
                st = '[green]'
                en = '[/green]'
            elif yi==y and xi==x:
                st = '[yellow]'
                en = '[/yellow]'
            elif (xi,yi) in surrounds:
                st = '[blue]'
                en = '[/blue]'
            else:
                st=''
                en=''
            if 0 <= xi < W and 0 <= yi < H:
                print(f'{st}{digits[(xi,yi)]}{en}', end="")
        print()
    print(int(get_digit(digits, x0, y0, l)))
    input()

#@solution_timer(2023,3,1)
def part_one(data: List[str], verbose=False):
    digits, starts, _ = parse(data)
    W = len(data[0])
    H = len(data)
    tot = 0
    for x0, y0, l in starts:
        surrounds = list(iterate_around((x0,y0),l))
        for x,y in surrounds:
            if 0 <= x < W and 0 <= y < H:
                if digits[(x,y)] not in '.0123456789': 
                    tot += int(get_digit(digits, x0, y0, l))
                    if verbose:
                        print(f'({x},{y}): {digits[(x,y)]} - {get_digit(digits, x0, y0, l)}')
                        pprint(x0, y0, x, y, l, digits, H, W, True, surrounds)
                    break
        else: 
            if verbose:
                pprint(x0, y0, 0, 0, l, digits, H, W, False, surrounds)
    return tot

def part_of_number(x: int,y: int,W: int, digits: PointDict):
    output = []
    if not digits[(x,y)].isdigit():
        return output
    for forwards in range(x,x+5):
        if 0 <= forwards < W and digits[(forwards,y)].isdigit() :
            output.append((forwards,y))
        else:
            break
    for backwards in range(x, x-6, -1):
        if 0 <= backwards < W and digits[(backwards,y)].isdigit():
            output.append((backwards,y))
        else:
            break
    return sorted(list(set(output)))

def get_number(digits, points):
    return int(''.join([digits[c] for c in points]))

def prod(a):
    return a[0]*a[1]

#@solution_timer(2023,3,2)
def part_two(data: List[str], verbose=False):
    digits, _, stars = parse(data)
    W = len(data[0])
    H = len(data)
    tot = 0
    for x0, y0 in stars:
        surrounds = list(iterate_around((x0,y0),1))
        digit_count = 0
        skips = []
        numbers = []
        for x,y in surrounds:
            if digits[(x,y)].isdigit() and (x,y) not in skips:
                digit_count += 1
                a = part_of_number(x,y,W,digits)
                skips.extend(a)
                numbers.append(a)
        if digit_count == 2:
            tot += prod([get_number(digits, n) for n in numbers])
            
        # print(skips)
    return tot

if __name__ == "__main__":
    data = read_entire_input(2023,3)
    part_one(data)
    part_two(data)