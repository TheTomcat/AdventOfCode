"""Autogenerated solution template, v2"""
__version__ = 2

from operator import itemgetter
from typing import Generator, Iterator, List, Any, Literal, Optional, Tuple
from framework.helpers import solution_timer
from framework.input_helper import read_entire_input
from lib.iterators import grouper, window
# from rich import print

# data = '\n'.join(read_entire_input(2023,5)).split('\n\n')

data = read_entire_input(2023,5)
# data = '\n'.join(data).split('\n\n')
test = """seeds: 79 14 55 13

seed-to-soil map:
50 98 2
52 50 48

soil-to-fertilizer map:
0 15 37
37 52 2
39 0 15

fertilizer-to-water map:
49 53 8
0 11 42
42 0 7
57 7 4

water-to-light map:
88 18 7
18 25 70

light-to-temperature map:
45 77 23
81 45 19
68 64 13

temperature-to-humidity map:
0 69 1
1 0 69

humidity-to-location map:
60 56 37
56 93 4""".split("\n")

def parse(data: List[str]):
    data = '\n'.join(data).split('\n\n')
    seeds: List[int] = [int(i) for i in data[0].split(": ")[1].split(" ")]
    maps = data[1:]
    # print(maps)
    output: dict[Tuple[str,str],List[Tuple[int,int,int]]] = {}
    for i, map in enumerate(maps):
        lines = map.split("\n")
        # print(map)
        # if len(lines) <= 1:
        #     continue
        # print(lines[1])
        a = lines[0].split(" ")[0].split("-")
        try:
            key = a[0], a[2]
        except IndexError as e:
            # print(i, a)
            raise e
        # source_category, destination_category
        output[key] = []
        for line in lines[1:]:
            output[key].append([int(i) for i in line.split(" ")])
            # source_start, destination_start, length =
    return seeds, output

MappingList = list[tuple[Tuple[int, int], Tuple[int, int]]]

class Mapping:
    def __init__(self, names: Tuple[str,str], mappings: List[Tuple[int,int,int]]):
        self.source, self.destination = names
        self.domains: List[Tuple[int,int]] = []
        self.ranges: List[Tuple[int,int]] = []
        mappings.sort(key=lambda x: x[1])
        for destination_start,source_start, length in mappings:
            self.domains.append((source_start, source_start+length))
            self.ranges.append((destination_start, destination_start+length))
    def in_domain(self, x: int) -> bool:
        for start, end in self.domains:
            if start <= x < end:
                return True
        return False
    
    def loop_over(self, sort_source=True) -> MappingList:
        if sort_source:
            f = lambda x: x[0][0]
        else:
            f = lambda x: x[1][0]
        el = sorted(zip(self.domains, self.ranges), key=f)
        # yield from el
        return el
        # for (d1,d2),(r1,r2) in el:
        #     print(d1,d2,r1,r2)

    
    def __call__(self, x: int) -> int:
        for (domain_start, domain_end), (range_start, range_end) in zip(self.domains, self.ranges):
            if domain_start <= x < domain_end:
                return range_start + (x - domain_start)
        return x
    
    def __add__(self, other: 'Mapping') -> List['Mapping']:
        if not isinstance(other, Mapping):
            raise TypeError
        output = []

class Seed:
    def __init__(self, start: int, length: int, _start:int = None, _offset: int = 0, domain='seed'):
        self.start = start
        self.length = length
        self._start = _start if _start is not None else start
        self._offset = _offset
        self._domain = domain
    def split(self, split_at: int) -> Optional['Seed']:
        if not self.start <= split_at < self.start + self.length:
            raise ValueError(f"Cannot split, split {split_at} outside of range ({self.start},{self.start+self.length})")
            # return None
        l1 = split_at - self.start
        l2 = self.length - (split_at - self.start)
        # c = Seed(split_at, l2, self._start, self._offset + l1, self._domain)
        d = Seed(self.start, l1 , self._start, self._offset, self._domain)
        # self.length = l1
        self.start = split_at
        self.length = l2
        self._offset += l1
        return d
    def transform(self, mapping: Mapping, verbose=False):
        if mapping.source != self._domain:
            raise ValueError(f"Seed Domain {self._domain} does not match Mapping Source {mapping.source}")
        for ((d1,d2),(r1,r2)) in mapping.loop_over():
            if d1 <= self.start < self.start + self.length < d2:
                if verbose:
                    print("Transforming seed")
                t = self.start - d1
                self.start = r1 + t
                self._domain = mapping.destination
                # print("Transforming seed")
                break
        else:
            raise ValueError(f"Seed {self} is too big for mapping {d1,d2}")

        
        # if not self.start <= split_at < self.start + self.length:
        #     return (self, None)
        # l1 = split_at - self.start
        # l2 = self.length - (split_at - self.start)
        # return (
        #     Seed(self.start, l1 , self._start, self._offset),
        #     Seed(split_at, l2, self._start, self._offset + l1)
        # )

        
    def split_(self, mapping: Mapping, verbose=False) -> Generator['Seed', Any, Any]:
        in_range = False
        start = self.start
        end = self.start + self.length
        els = list(mapping.loop_over()) # iterate over the mappings in order
        (d1,d2),_ = els[0]
        print('els ', els)
        if end <= d1: # Seed range out of mapping
            if verbose:
                print(f"seed out of mapping:        {self.start}, {self.length}")
            yield self
        for i, ((d1,d2),(r1,r2)) in enumerate(els):
            print(f'{start},{end} -> {d1},{d2}')
            if d2 <= start:
                continue
            if d1 <= start <= d2 < end: 
                # Start within range
                length_before = start - d1
                length_within = d2 - start
                # if verbose:
                print(f"Start within range:         {r1 + length_before}, {length_within}")
                yield Seed(r1 + length_before, length_within, self._start)
            if start <= d1 <= d2 <= end: 
                # Seed 
                # if verbose:
                print(f"range enclosed wtihin seed: {r1},{r2-r1}")
                yield Seed(r1,r2-r1,self._start)
            if start <= d1 <= end < d2: # End within range
                length_before = end - d1
                length_within = d2 - end
                # if verbose:
                print(f"end wtihin range:           {r1+length_before},{length_within}")
                yield Seed(r1+length_before, length_within, self._start)
            if d1 <= start <= end <= d2:
                length_before = start - d1
                yield Seed(r1+length_before, self.length, self._start)
    def __repr__(self):
        return f'({self.start}, len={self.length} [{self._start}->{self._offset}:{self._domain}])'

def evaluate_mapping_chain(
        mappings: dict[str, 'Mapping'], 
        x: int,
        start='seed',
        end='location') -> int:
    key = start
    while True:
        if key == end:
            return x
        m = mappings[key]
        x = m(x)
        key = m.destination

def build_mappings(maps: dict[Tuple[str, str], List[Tuple[int, int, int]]], verbose=False) -> dict[str, 'Mapping']:
    d: dict[str, 'Mapping'] = {}
    for names, mappings in maps.items():
        m = Mapping(names, mappings)
        if verbose:
            print(names, len(mappings))
        d[names[0]] = m
    return d


def build_seeds(seeds: List[int]) -> List['Seed']:
    s = []
    for start, length in grouper(2, seeds):
        s.append(Seed(start, length))
    return s

def debug(mappings: dict[str, 'Mapping']):
    for col in mappings:
        print(f'{col[:10]:10}', end="   ")
    print()
    for x in range(100):
        v = x
        for col, mapping in mappings.items():
            print(f'{v:10}', end="")
            v = mapping(v)
        print()

#@solution_timer(2023,5,1)
def part_one(data: List[str], verbose=False):
    seeds, maps = parse(data)

    d = build_mappings(maps, verbose)

    minimum = 1E10
    for seed in seeds:
        minimum = min(minimum, evaluate_mapping_chain(d, seed))
    return minimum


def print_seeds(seeds: List['Seed']):
    print(", ".join(str(s) for s in seeds))

def mix_seed(seeds: List['Seed'], mapping: 'Mapping', verbose=False) -> List['Seed']:
    output = []
    for seed in seeds:
        new_seeds = list(seed.split_(mapping, verbose))
        output.extend(new_seeds)
    return output

def mix_all(
        seeds: List['Seed'], 
        mappings: dict[str, Mapping], 
        verbose=False,
        start='seed',
        end='location'):
    key = start
    while True:
        if key == end:
            return seeds
        
        m = mappings[key]
        seeds = mix_seed(seeds, m, verbose)
        key = m.destination
        if verbose:
            print_seeds(seeds)
    # return seeds

def find_breakpoints(seed: Seed, mapping: Mapping) -> List[int]:
    start = seed.start
    length = seed.length

    el = mapping.loop_over()
    end = start + length

    # print(el)
    intersected_ranges = [
        e for e in el 
        if e[0][0]<=start < e[0][1] or 
        start <=e[0][0] < e[0][1] < end or 
        e[0][0] < end < e[0][1]
    ]
    cut_points = [
        # start,
        *[e[0][0] for e in intersected_ranges[1:]],
        # end,
    ]
    return cut_points

def map_seeds(seeds: List['Seed'], mapping: 'Mapping'):
    new_seeds: List['Seed'] = []
    for seed in seeds:
        cut_points = find_breakpoints(seed, mapping)
        print(cut_points)
        for cut in cut_points:
            a = seed.split(cut)
            new_seeds.append(a)
        new_seeds.append(seed)
    for seed in new_seeds:
        seed.transform(mapping)
    return new_seeds
    print(new_seeds)

def apply_all_maps(
        seeds: List['Seed'], 
        mappings: dict[str, Mapping],
        verbose=False,
        start='seed',
        end='location'):
    key = start
    # new_seeds = []
    while True:
        if key == end:
            return seeds
        m = mappings[key]
        if verbose:
            print(f'Applying map {m.source}->{m.destination}')
        seeds = map_seeds(seeds, m)
        key = m.destination
        if verbose:
            print_seeds(seeds)

def split(seedlist: List['int'], split_at: int) -> List['int']:
    output = []
    for start, length in  grouper(2, seedlist):
        if start <= split_at < start + length:
            l1 = split_at - start
            l2 = length - l1
            output.extend([start, l1, split_at, l2])
        else:
            output.extend([start, length])
    return output

def find_splits(seed: Tuple[int,int], mapping: List[Tuple[int,int,int]]):
    start, length = seed
    end = start + length
    filtered_maps = list(filter(intersects(seed), mapping))
    print(filtered_maps)

def intersects(seed: Tuple[int,int]):
    def f(mapping: Tuple[int,int,int]):
        nonlocal seed
        start, length = seed
        end = start + length
        rstart, dstart, mlength = mapping
        dend = dstart + mlength
        return (dstart <= start < dend or  # Seed start in map
                dstart <= end < dend or    # Seed end in map
                start < dstart < dend < end) # Seed fully contains map
    return f

#@solution_timer(2023,5,2)
def part_two(data: List[str], verbose=False):
    s, m = parse(data)
    mappings = build_mappings(m, verbose)
    seeds = build_seeds(s)
    
    find_splits(s[0:2], m[('seed', 'soil')])


    # seeds = apply_all_maps(seeds, mappings, True)
    # print(seeds)



    # intersections(s[0], d['seed'])
    # intersections(s[1], d['seed'])
    # print(s[0])
    # s[0].transform(d['seed'])
    # print(s[0])
    # x = s[0].split(86)
    # print(s[0])
    # print(x)
    # print("Original seeds: ", end="")
    # print_seeds(s)
    # 
    # # s2 = mix_seed(s, d['seed'], True)
    # #s2 = list(list(x.split(d['seed'], True)) for x in s)
    # # s2 = [*(list(seed.split(d['seed'])) for seed in s)]
    # # print("Soil: ", end="")
    # # print_seeds(s2)
    # print("---")
    # s = mix_all(s, d, True)
    # # debug(d)
    # print_seeds(s)
    return False

if __name__ == "__main__":
    data = read_entire_input(2023,5)
    part_one(data)
    part_two(data)